<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Java并发编程实战：AQS</title>
      <link href="/2018/09/09/AQS/"/>
      <url>/2018/09/09/AQS/</url>
      
        <content type="html"><![CDATA[<h4 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h4><p>AQS(AbstractQueuedSynchronizer)    同步器 JDK1.5    提供了  java    .util.concurrent 包（JUC）大大的提升了并发性能，而AQS是JUC的核心。AQS是基于FIFO的队列，可以用来构建锁和其他同步装置的基础框架。</p><h4 id="AQS介绍"><a href="#AQS介绍" class="headerlink" title="AQS介绍"></a>AQS介绍</h4><ul><li>使用Node实现FIFO队列，可以用于构建锁或其他同步装置的基础框架。</li><li>利用了int类型表示状态</li><li>子类通过继承AbstractQueuedSynchronizer类实现它法管理器状态的方法来操作状态。</li><li>可以同时实现排它锁和共享锁模式。</li></ul><p>AQS内部维护了一个CLH队列来管理锁，线程尝试获取锁，如果失败，就将当前线程以及等待状态等信息会包装成一个Node节点，加入到同步队列Sync Queue尾部，同时阻塞当前线程，当同步状态释放时，唤醒队列的头节点。</p><h4 id="AbstractQueuedSynchronizer-源码浅析"><a href="#AbstractQueuedSynchronizer-源码浅析" class="headerlink" title="AbstractQueuedSynchronizer 源码浅析"></a>AbstractQueuedSynchronizer 源码浅析</h4><p>AbstractQueuedSynchronizer是一个抽象类，定义了两种资源共享方式：SHARED（共享）和EXCLUSIVE（独占）</p><pre class="line-numbers language-Java"><code class="language-Java">    static final class Node {    /** Marker to indicate a node is waiting in shared mode */    static final Node SHARED = new Node();    /** Marker to indicate a node is waiting in exclusive mode */    static final Node EXCLUSIVE = null;    ......    }    private transient volatile Node head;    private transient volatile Node tail;    private volatile int state;    protected final int getState() {        return state;    }    protected final void setState(int newState) {        state = newState;    }     //通过CAS算法set state    protected final boolean compareAndSetState(int expect, int update) {     return unsafe.compareAndSwapInt(this, stateOffset, expect, update);    }<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>自定义同步器需要继承AbstractQueuedSynchronizer实现state的获取和释放方法。</p><h4 id="Acquire-和-Release"><a href="#Acquire-和-Release" class="headerlink" title="Acquire 和 Release"></a>Acquire 和 Release</h4><ul><li><p>protected boolean tryAcquire(int arg)：<br>以独占的方式尝试获取资源，成功返回true，反之false。</p></li><li><p>protected int tryAcquireShared(int arg)：<br>以共享方式尝试获取资源。成功返回值0，但没有剩余可用资源，有剩余资源返回值&gt;0,失败返回值&lt; 0。</p></li><li><p>protected boolean tryRelease(int arg)<br>独占方式尝试释放资源，成功则返回true，失败则返回false。</p></li><li><p>protected boolean tryReleaseShared(int arg) 共享方式尝试释放资源，如果释放后允许唤醒后续等待结点返回true，否则返回false。</p></li></ul><h4 id="CountDownLatch"><a href="#CountDownLatch" class="headerlink" title="CountDownLatch"></a>CountDownLatch</h4><p>CountDownLatch是一种灵活的闭锁实现，它可以使一个或者多个线程等待一组事件发生。闭锁包括一个计数器，该计数器初始化时是一个正数，表示等待的事件数量，countDown方法递减计数器，表示一个事件发生了，而await方法等待计数器达到零，表示所有需要等待的事件都已发生。如果非零，那么await方法会一直阻塞到计数器为零，或者等待线程中断或超时。</p><h5 id="基本用法"><a href="#基本用法" class="headerlink" title="基本用法"></a>基本用法</h5><pre class="line-numbers language-Java"><code class="language-Java">public class CountDownLatchDemo {    private final static int threadCount = 10;    public static void main(String[] args) throws InterruptedException {        ExecutorService executorService = Executors.newCachedThreadPool();        final CountDownLatch countDownLatch = new CountDownLatch(threadCount);        for (int i = 0; i < threadCount; i++) {            final int threadNum = i;            executorService.execute(() -> {                try {                    Thread.sleep(100);                    System.out.println("threadNum : " + threadNum + " executed");                } catch (InterruptedException e) {                    e.printStackTrace();                }finally {                    countDownLatch.countDown();                }            });        }        countDownLatch.await();        System.out.println("executed finish");    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h5 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h5><p>可以看出,CountDownLatch实现了AQS的tryAcquireShared和tryReleaseShared方法，是以共享方式获取和释放资源的。</p><pre class="line-numbers language-Java"><code class="language-Java">public class CountDownLatch {    /**     * Synchronization control For CountDownLatch.     * Uses AQS state to represent count.     */    private static final class Sync extends AbstractQueuedSynchronizer {        private static final long serialVersionUID = 4982264981922014374L;        Sync(int count) {            setState(count);        }        int getCount() {            return getState();        }        protected int tryAcquireShared(int acquires) {            return (getState() == 0) ? 1 : -1;        }        protected boolean tryReleaseShared(int releases) {            // Decrement count; signal when transition to zero            for (;;) {                int c = getState();                if (c == 0)                    return false;                int nextc = c-1;                if (compareAndSetState(c, nextc))                    return nextc == 0;            }        }    }    private final Sync sync;    ...      public void countDown() {        sync.releaseShared(1); //父类AQS的方法    }    }        //  父类AQS的releaseShared     public final boolean releaseShared(int arg) {        if (tryReleaseShared(arg)) {//子类CountDownLatch的实现            doReleaseShared();            return true;        }        return false;    }<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>CountDownLatch将任务分为count个线程与执行，将state初始化等于count，线程并行执行，每完成一个后countDown()一次调用tryReleaseShared，将state通过CAS算法减1。等到所有子线程都执行完后(即state=0)，会unpark()主调用线程，然后主调用线程就会从await()函数返回，继续后余动作。</p><h4 id="Semaphore-信号量"><a href="#Semaphore-信号量" class="headerlink" title="Semaphore(信号量)"></a>Semaphore(信号量)</h4><blockquote><p>计数信号量用来控制访问某个特定的资源的操作数量，或者同时执行某个制定操作的数量。</p></blockquote><h5 id="使用Semaphore"><a href="#使用Semaphore" class="headerlink" title="使用Semaphore"></a>使用Semaphore</h5><p>Semaphore中管理这一组虚拟的许可（permit），许可的初始数量可以通过构造函数指定，在执行操作时可以先获取许可（acquire（）），并在使用后释放（release（））；</p><pre class="line-numbers language-Java"><code class="language-Java">/*** 执行10个线程操作，一次3个执行并发线程。**/public class SemaphoreDemo {    private final static int threadCount = 10;    public static void main(String[] args) throws InterruptedException {        ExecutorService executorService = Executors.newCachedThreadPool();        //通过构造函数制定许可（permit=3）        Semaphore semaphore = new Semaphore(3);        for (int i = 0; i < threadCount; i++) {            final int threadNum = i;            executorService.execute(() -> {                try {                //开始操作时获取许可                    semaphore.acquire();                    Thread.sleep(2000);                    System.out.println("threadNum : " + threadNum + " executed");                    //操作介绍时释放                    semaphore.release();                } catch (InterruptedException e) {                    e.printStackTrace();                }            });        }    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 多线程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 多线程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java线程安全：可见性，原子性，有序性</title>
      <link href="/2018/09/03/juc1/"/>
      <url>/2018/09/03/juc1/</url>
      
        <content type="html"><![CDATA[<h4 id="Java线程安全"><a href="#Java线程安全" class="headerlink" title="Java线程安全"></a>Java线程安全</h4><p>可见性，原子性，有序性</p><h4 id="Java内存模型（JMM）"><a href="#Java内存模型（JMM）" class="headerlink" title="Java内存模型（JMM）"></a>Java内存模型（JMM）</h4><p>Java内存模型（Java Memory Model）描述了Java程序中各种变量（线程共享变量）的访问规则，以及在JVM中将变量存储到内存和从内存中读取变量这样的底层细节。</p><ul><li>所有的变量都存储在主内存中。</li><li><p>每个线程都有自己独立的工作内存，里面保持该线程使用到的变量副本。<br><img src="http://on-img.com/chart_image/5b8be790e4b08faf8c40528e.png?_=1535897708891" alt=""></p></li><li><p>线程对共享变量的所有操作都必须在自己的工作内存中进行，不能直接从主内存中进行读写。</p></li><li><p>不同线程之间无法直接访问其他线程工作内存的变量，所以线程间变量值的传递需要通过主内存来完成。</p></li></ul><h4 id="如何实现可见性"><a href="#如何实现可见性" class="headerlink" title="如何实现可见性"></a>如何实现可见性</h4><p>要实现共享变量的可见性，必须保证两点：</p><ul><li>线程修改后的共享变量值能够及时从工作内存刷到主内存中。</li><li>其他线程能够及时把共享变量的最新值从主内存更新到自己的工作内存中。</li></ul><h4 id="synchronized实现可见性"><a href="#synchronized实现可见性" class="headerlink" title="synchronized实现可见性"></a>synchronized实现可见性</h4><p>JMM关于synchronized的两条规定：</p><ul><li>线程解锁前，必须把共享变量的最新值刷新到主内存中。</li><li>线程加锁时，将清空工作内存中共享变量的值，从而使用共享变量时候需要从主内存中重新读取最新值。</li></ul><h5 id="线程执行互斥代码的过程："><a href="#线程执行互斥代码的过程：" class="headerlink" title="线程执行互斥代码的过程："></a>线程执行互斥代码的过程：</h5><ul><li>获取互斥锁</li><li>清空工作内存</li><li>从主内存拷贝变量最新值到工作内存中</li><li>执行代码</li><li>将更改后的共享变量的值刷新到主内存中</li><li>释放互斥锁</li></ul><h5 id="Synchronized的使用"><a href="#Synchronized的使用" class="headerlink" title="Synchronized的使用"></a>Synchronized的使用</h5><ul><li>修饰代码快：{}里的代码块，作用与调用对象</li><li>修饰方法：整个方法，作用于调用的对象</li><li>修饰静态的方法：整个静态方法，作用于所有对象</li><li>修饰类：{}括起来的部分，作用于所有对象</li></ul><pre class="line-numbers language-Java"><code class="language-Java">public class SyncExample {    //修饰代码快    public void test1(String name){        synchronized (this){            for (int i = 0; i < 10; i++){                System.out.println(name + ":" + i);            }        }    }    //修饰方法    public synchronized void test2(String name){        for (int i = 0; i < 10; i++){            System.out.println(name + ":" +i);        }    }    public static void main(String[] args) {        final SyncExample sync1 = new SyncExample();        SyncExample sync2 = new SyncExample();        ExecutorService executorService = Executors.newCachedThreadPool();        executorService.execute(() -> sync1.test1("sync1"));        executorService.execute(() -> sync2.test1("sync2"));    }}//结果sync2:0sync1:0sync2:1sync1:1sync2:2sync1:2sync1:3sync2:3sync1:4sync2:4sync1:5sync2:5sync1:6sync2:6sync1:7sync2:7sync1:8sync2:8sync1:9sync2:9<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>sync1和sync2的test1交替执行，说明同步代码块作用在当前对象，不同对象调用互不影响。</p><p>当换成test2（）时，结果和上相同，说明synchronized修饰一个方法时，作用和同步代码块相同，都是作用当前对象。</p><p>所以，如果一个方法中是一个完整的同步代码快，它和synchronized修饰一个方法是等同的。</p><p>当修饰一个类时</p><pre class="line-numbers language-Java"><code class="language-Java">  public static void test3(){        synchronized (SyncExample.class){            for (int i = 0; i < 5; i++) {                System.out.println(Thread.currentThread() + "test3 :" + i + " ");            }        }    }Thread[pool-1-thread-1,5,main]test3 :0 Thread[pool-1-thread-1,5,main]test3 :1 Thread[pool-1-thread-1,5,main]test3 :2 Thread[pool-1-thread-1,5,main]test3 :3 Thread[pool-1-thread-1,5,main]test3 :4 Thread[pool-1-thread-2,5,main]test3 :0 Thread[pool-1-thread-2,5,main]test3 :1 Thread[pool-1-thread-2,5,main]test3 :2 Thread[pool-1-thread-2,5,main]test3 :3 Thread[pool-1-thread-2,5,main]test3 :4 <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>从结果上可以看出，修饰一个类时，作用于这个类的所有对象。</p><h4 id="volatile-实现可见性"><a href="#volatile-实现可见性" class="headerlink" title="volatile 实现可见性"></a>volatile 实现可见性</h4><p>volatile通过加入内存屏障和禁止重排序优化来实现可见性</p><ul><li>对volatile变量执行写操作时，会在写操作后加入一条store屏障指令</li><li>对volatile变量执行读操作时，会在读操作前加入一条load屏障指令</li></ul><p>volatile变量在每次被线程访问时，都强迫从主内存中读取该变量的值，而当发生变化时，会强迫线程将最新的值刷新到主内存。</p><ul><li>线程写volatile变量的过程</li></ul><ol><li>改变线程工作内存中volatile变量副本的值。</li><li>将改变后的副本的值重工作内存刷新到主内存</li></ol><ul><li>线程度volatile变量的过程</li></ul><ol><li>将主内存中读取volatile变量的最新值到工作内存中。</li><li>从工作内存中读取volatile变量的副本。</li></ol><h4 id="volatile不能保证原子性"><a href="#volatile不能保证原子性" class="headerlink" title="volatile不能保证原子性"></a>volatile不能保证原子性</h4><pre class="line-numbers language-Java"><code class="language-Java">private int number = 0;number ++;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>number ++ 不是原子操作，可以分为三步<br>1.读取number的值，2.将number值+1，3.写入最新的numnber的值</p><pre class="line-numbers language-Java"><code class="language-Java">public class TestAtomicDemo {    public static void main(String[] args) {        AtomicDemo demo = new AtomicDemo();        for (int i = 0; i < 10; i ++){            new Thread(demo).start();        }    }}class AtomicDemo implements Runnable{    private volatile int serialNumber = 0;    public void run() {        try {            Thread.sleep(2000);        } catch (InterruptedException e) {            e.printStackTrace();        }        System.out.println(Thread.currentThread().getName() +":"+getSerialNumber());    }    public int getSerialNumber(){        return serialNumber ++;    }}Thread-0:0Thread-1:1Thread-3:3Thread-2:2Thread-5:4Thread-4:5Thread-6:7Thread-7:7Thread-8:6Thread-9:8<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>可以看到Thread6和Thread7的执行结果相同。</p><h4 id="原子性"><a href="#原子性" class="headerlink" title="原子性"></a>原子性</h4><p>原子性：提供了互斥访问，同一时刻，只能由一个线程对它进行操作。</p><p>jdk1.5后java.util.concurrent.atomic包下面提供可常用的原子变量。CAS（Compare-And-Swap）算法保证数据原子性。</p><pre class="line-numbers language-Java"><code class="language-Java">private volatile AtomicInteger serialNumber = new AtomicInteger(0); public int getSerialNumber(){        return serialNumber.incrementAndGet();    }<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>AtomicInteger的incrementAndGet()方法是如何保证原子性的呢？</p><pre class="line-numbers language-Java"><code class="language-Java">private static final jdk.internal.misc.Unsafe U = jdk.internal.misc.Unsafe.getUnsafe();    private static final long VALUE = U.objectFieldOffset(AtomicInteger.class, "value");    private volatile int value;    /**     * Atomically increments the current value,     * with memory effects as specified by {@link VarHandle#getAndAdd}.     *     * <p>Equivalent to {@code addAndGet(1)}.     *     * @return the updated value     */    public final int incrementAndGet() {        return U.getAndAddInt(this, VALUE, 1) + 1;    }<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>从源码（我的是JDK10）中可以看到AtomicInteger使用了一个Unsafe类的getAndAddInt方法。</p><pre class="line-numbers language-Java"><code class="language-Java">/**     * Atomically adds the given value to the current value of a field     * or array element within the given object {@code o}     * at the given {@code offset}.     *     * @param o object/array to update the field/element in     * @param offset field/element offset     * @param delta the value to add     * @return the previous value     * @since 1.8     */    @HotSpotIntrinsicCandidate    public final int getAndAddInt(Object o, long offset, int delta) {        int v;        do {            v = getIntVolatile(o, offset);        } while (!weakCompareAndSetInt(o, offset, v, v + delta));        return v;    }<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>getIntVolatile方法，如果没有其他线程来处理Object o，这个方法返回只v就等于offset。<br>weakCompareAndSetInt方法就是CAS算法核心<br>offset为内存值，v是预估值，v+delta为更新值，当且仅当offset==v，才会+1操作。</p><h4 id="有序性"><a href="#有序性" class="headerlink" title="有序性"></a>有序性</h4><p>Java内存模型中，允许编译器和处理器对指令进行重排序，但是重排序的过程不会影响单线程的执行结果，却会影响到多线程并发执行的正确性。</p><p> volatile， synchronized，Lock，可以保证有序性</p><h5 id="happens-before原则"><a href="#happens-before原则" class="headerlink" title="happens-before原则"></a>happens-before原则</h5><ol><li>程序次序规则：一个线程内，按照代码顺序，书写在前的操作先于后的操作。Java虚拟机只会对没有数据依赖的代码进行重排序。</li><li>锁定规则，一个unLock操作先行发生于后面对同一个锁的lock操作。</li><li>volatile变量规则：对一个变量的写操作先行发生于后面对这个变量的读操作。</li><li>传递规则：提现了happens-before原则具有传递性，即A happens-before B , B happens-before C，那么A happens-before C</li><li>线程启动规则：假定线程A在执行过程中，通过执行ThreadB.start()来启动线程B，那么线程A对共享变量的修改在接下来线程B开始执行后确保对线程B可见。</li><li>线程终结规则：假定线程A在执行的过程中，通过制定ThreadB.join()等待线程B终止，那么线程B在终止之前对共享变量的修改在线程A等待返回后可见。</li><li>对象终结规则：一个对象的初始化完成先行发生于它的finalize（）方法的开始。</li></ol>]]></content>
      
      
      <categories>
          
          <category> 多线程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 多线程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Tomcat基本原理</title>
      <link href="/2018/07/03/tomcat/"/>
      <url>/2018/07/03/tomcat/</url>
      
        <content type="html"><![CDATA[<p>Tomcat是Apache软件基金会（Apache Software Foundation）的Jakarta项目中的一个核心项目。一个免费的开放源代码的Web应用服务器。</p><h4 id="Tomcat组件介绍"><a href="#Tomcat组件介绍" class="headerlink" title="Tomcat组件介绍"></a>Tomcat组件介绍</h4><p><img src="http://wx2.sinaimg.cn/mw690/9dd01c34ly1g2ab1zcz89j20us0ki0v4.jpg" alt=""><br>上图是Tomcat的总体结构：    </p><ul><li>Server指的是tomcat服务器，主要负责管理和启动多个Service，一个Server可以包含多个Service。各个Service之间是独立的，共享虚拟机资源。有了Service就可以对外提供服务了，<br>Service需要Server的资源环境，Tomcat的整个生命周期有Server掌控。</li><li>Tomcat的两个核心组件：Connector和Container，<br>Connector是Tomcat与外部世界的连接器，监听固定的端口接收外部请求。然后将请求传递给Container，并且将Container处理的请求结果返回给外部。<br>Container是一个Servlet容器，主要接收Connector请求。它有四个子容器组件构成，主要管理Servlet的生命周期。<br>一个Service可以设置多个Connector，但是只能有一个Container。</li></ul><h4 id="Server"><a href="#Server" class="headerlink" title="Server"></a>Server</h4><p>Server的任务很简单，就是提供接口让其他程序访问到Service集合，维护Service的生命周期,从Server的源码中可以看到所提供的方法。</p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">interface</span> <span class="token class-name">Server</span> <span class="token keyword">extends</span> <span class="token class-name">Lifecycle</span> <span class="token punctuation">{</span>     <span class="token keyword">public</span> NamingResourcesImpl <span class="token function">getGlobalNamingResources</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">setGlobalNamingResources</span>            <span class="token punctuation">(</span>NamingResourcesImpl globalNamingResources<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">public</span> javax<span class="token punctuation">.</span>naming<span class="token punctuation">.</span>Context <span class="token function">getGlobalNamingContext</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">getPort</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">setPort</span><span class="token punctuation">(</span><span class="token keyword">int</span> port<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">getPortOffset</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">setPortOffset</span><span class="token punctuation">(</span><span class="token keyword">int</span> portOffset<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">getPortWithOffset</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">public</span> String <span class="token function">getAddress</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">setAddress</span><span class="token punctuation">(</span>String address<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">public</span> String <span class="token function">getShutdown</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">setShutdown</span><span class="token punctuation">(</span>String shutdown<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">public</span> ClassLoader <span class="token function">getParentClassLoader</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">setParentClassLoader</span><span class="token punctuation">(</span>ClassLoader parent<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">public</span> Catalina <span class="token function">getCatalina</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">setCatalina</span><span class="token punctuation">(</span>Catalina catalina<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">public</span> File <span class="token function">getCatalinaBase</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">setCatalinaBase</span><span class="token punctuation">(</span>File catalinaBase<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">public</span> File <span class="token function">getCatalinaHome</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">setCatalinaHome</span><span class="token punctuation">(</span>File catalinaHome<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">getUtilityThreads</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">setUtilityThreads</span><span class="token punctuation">(</span><span class="token keyword">int</span> utilityThreads<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">addService</span><span class="token punctuation">(</span>Service service<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">await</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">public</span> Service <span class="token function">findService</span><span class="token punctuation">(</span>String name<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">public</span> Service<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token function">findServices</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">removeService</span><span class="token punctuation">(</span>Service service<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">public</span> Object <span class="token function">getNamingToken</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">public</span> ScheduledExecutorService <span class="token function">getUtilityExecutor</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="Service"><a href="#Service" class="headerlink" title="Service"></a>Service</h4><p>下面是Service接口源码</p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">interface</span> <span class="token class-name">Service</span> <span class="token keyword">extends</span> <span class="token class-name">Lifecycle</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> Engine <span class="token function">getContainer</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">setContainer</span><span class="token punctuation">(</span>Engine engine<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">public</span> String <span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">setName</span><span class="token punctuation">(</span>String name<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">public</span> Server <span class="token function">getServer</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">setServer</span><span class="token punctuation">(</span>Server server<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">public</span> ClassLoader <span class="token function">getParentClassLoader</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">setParentClassLoader</span><span class="token punctuation">(</span>ClassLoader parent<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">addConnector</span><span class="token punctuation">(</span>Connector connector<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">public</span> Connector<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token function">findConnectors</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">removeConnector</span><span class="token punctuation">(</span>Connector connector<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">addExecutor</span><span class="token punctuation">(</span>Executor ex<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">public</span> Executor<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token function">findExecutors</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">public</span> Executor <span class="token function">getExecutor</span><span class="token punctuation">(</span>String name<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">removeExecutor</span><span class="token punctuation">(</span>Executor ex<span class="token punctuation">)</span><span class="token punctuation">;</span>    Mapper <span class="token function">getMapper</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>通过setContainer方法和addConnector方法，将Connector和Container两大核心组件包在Service中。<br>这些组件的生命周期都是Liftcycle接口控制。</p><h4 id="Liftcycle"><a href="#Liftcycle" class="headerlink" title="Liftcycle"></a>Liftcycle</h4><p>前面所说的Liftcycle控制了Service和Server的生命周期，组件可以继承这个接口。<br>Liftcycle提供了控制生命周期的Start和Stop方法，另外还提供了一些监听机制。</p><h4 id="Connector"><a href="#Connector" class="headerlink" title="Connector"></a>Connector</h4><p>Connector是Tomcat的核心主键之一，主要负责接收浏览器发过来的TCP连接请求，创建Request和Response对象用于请求端交换数据。<br>然后产生一个线程看来处理这个请求，将这个请求生成的Request和Response对象传递给处理请求的线程，也就是Container。</p><ul><li>下面是Connector处理请求顺序图：<br><img src="http://wx3.sinaimg.cn/mw690/9dd01c34ly1g2bt2m8ggwj20o00ls78j.jpg" alt=""></li></ul><h4 id="Container"><a href="#Container" class="headerlink" title="Container"></a>Container</h4><p>Conainer是所有容器的父接口，他有四个子容器组件组成，Engine，Host，Context，Wrapper。采用责任链模式，Engine包含Host，Host包含Context，Context包含Wrapper<br>通常一个 Servlet class 对应一个 Wrapper，如果有多个 Servlet 就可以定义多个 Wrapper，如果有多个 Wrapper 就要定义一个更高的 Container 了，如 Context，</p>]]></content>
      
      
      <categories>
          
          <category> Tomcat </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Tomcat </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java定时任务调度</title>
      <link href="/2018/06/26/JavaTimer/"/>
      <url>/2018/06/26/JavaTimer/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><blockquote><p>基于给定的时间点，给定的时间间隔或者给定的执行次数自动执行任务。</p></blockquote><h2 id="Timer"><a href="#Timer" class="headerlink" title="Timer"></a>Timer</h2><h3 id="Timer定义"><a href="#Timer定义" class="headerlink" title="Timer定义"></a>Timer定义</h3><blockquote><p>A facility for threads to schedule tasks for future execution in a background thread. Tasks may be scheduled for one-time execution, or for repeated execution at regular intervals.</p></blockquote><p>有且仅有一个后台线程对多个业务线程进行定时定频率的调度</p><h3 id="Timer构造方法"><a href="#Timer构造方法" class="headerlink" title="Timer构造方法"></a>Timer构造方法</h3><ul><li>Timer() 创建一个新计时器</li><li>Timer(boolean isDaemon) 创建一个新计时器，可以指定其相关的线程作为守护程序运行。isDaemon:如果应该将相关的线程作为守护程序运行，则为 true</li><li>Timer(String name) 创建一个新计时器，其相关的线程具有指定的名称  </li><li>Timer(String name,boolean isDaemon)创建一个新计时器，其相关的线程具有指定的名称，并且可以指定作为守护程序运行。name 相关线程的名称。isDaemon - 如果应该将相关的线程作为守护程序运行，则为 true。</li></ul><h3 id="调度方法-schedule的四种用法"><a href="#调度方法-schedule的四种用法" class="headerlink" title="调度方法 schedule的四种用法"></a>调度方法 schedule的四种用法</h3><ul><li>public void schedule(TimerTask task, long delay,  long period) 安排指定的任务从指定的延迟后开始进行重复的 固定延迟执行。以近似固定的时间间隔（由指定的周期分隔）进行后续执行。</li></ul><p>demo</p><pre class="line-numbers language-Java"><code class="language-Java">import java.util.TimerTask;public class MyTimerTask extends TimerTask{    private String name;    public MyTimerTask(String name) {        this.name = name;    }    @Override    public void run() {        Calendar calendar = Calendar.getInstance();        DateFormat format = new SimpleDateFormat("yyyy-MM-dd hh:mm:ss");        System.out.println("MyTimerTask " + name + format.format(calendar.getTime()));     }  //getter and setter}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li><p>schedule(TimerTask task, Date time) 安排在指定的时间执行指定的任务。如果此时间已过去，则安排立即执行该任务。</p><pre class="line-numbers language-Java"><code class="language-Java">Timer timer = new Timer();MyTimerTask myTimerTask1 = new MyTimerTask("No.1");//1 安排在指定的时间执行指定的任务。如果此时间已过去，则安排立即执行该任务//eg:当前时间三秒后执行Calendar calendar = Calendar.getInstance();DateFormat format = new SimpleDateFormat("yyyy-MM-dd hh:mm:ss");System.out.println(format.format(calendar.getTime()));calendar.add(Calendar.SECOND, 3);timer.schedule(myTimerTask1, calendar.getTime());<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>schedule(TimerTask task,  Date firstTime, long period) 时间等于或超过fisrtTime是执行task，之后每隔period重复执行一次task。</p></li><li>schedule(TimerTask task, long delay) 等待delay毫秒后执行且仅执行一次task。</li><li>schedule(TimerTask task, long delay, long period) 等待delay毫秒后首次执行task，之后每隔period毫秒重复执行一次task。</li></ul><h3 id="scheduleAtFixedRate"><a href="#scheduleAtFixedRate" class="headerlink" title="scheduleAtFixedRate"></a>scheduleAtFixedRate</h3><h4 id="首次执行时间早于当前时间"><a href="#首次执行时间早于当前时间" class="headerlink" title="首次执行时间早于当前时间"></a>首次执行时间早于当前时间</h4><p>  schedule(TimerTask task,  Date firstTime, long period)方法只能从当前时间开始执行，比如要当前时间是12:00:06,firstTime设为12:00:00，period设为2秒，那么schedule方法就不能执行firstTime到当前时间的三次task。<br>  而scheduleAtFixedRate(TimerTask task, Date firstTime, long period)在如果第一次执行时间被delay了，随后的执行时间会按照上一次任务开始的时间进行计算，并且为了赶上进度会多次执行任务。在方法调用时会立刻执行三次task。</p><h4 id="执行任务的时间超过执行任务的period"><a href="#执行任务的时间超过执行任务的period" class="headerlink" title="执行任务的时间超过执行任务的period"></a>执行任务的时间超过执行任务的period</h4><p>  schedule(TimerTask task, long delay, long period)方法的下次执行时间是在上一次任务结束period后 开始执行下一次任务。而scheduleAtFixedRate是在上一次任务开始period后执行下一次task。存在并发性。</p><h3 id="Timer的缺点"><a href="#Timer的缺点" class="headerlink" title="Timer的缺点"></a>Timer的缺点</h3><p>timer只有一个后台线程，管理并发任务存在缺馅；当一个task抛出异常时，其他的任务就不能执行了；不支持每周特定一天去执行任务。定时设置存在局限性。</p>]]></content>
      
      
      <categories>
          
          <category> Java Timer </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> Timer </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Redis入门</title>
      <link href="/2018/02/03/Redis/"/>
      <url>/2018/02/03/Redis/</url>
      
        <content type="html"><![CDATA[<h1 id="Redis入门"><a href="#Redis入门" class="headerlink" title="Redis入门"></a>Redis入门</h1><h2 id="初始redis"><a href="#初始redis" class="headerlink" title="初始redis"></a>初始redis</h2><p>redis是一个开源的、使用C语言编写的、支持网络交互å的、可基于内存也可持久化的Key-Value数据库与很多键值对<br>数据库不同的是，Redis中的值可以是由string（字符串）、hash（哈希）、<br>list（列表）、set（集合）、zset（有序集合）、Bitmaps（位图）、<br>HyperLogLog、GEO（地理信息定位）等多种数据结构和算法组成。</p><ul><li>Redis支持数据的持久化，可以将内存中的数据保持在磁盘中，重启的时候可以再次加载进行使用。</li><li>Redis不仅仅支持简单的key-value类型的数据，同时还提供list，set，zset，hash等数据结构的存储。</li><li>Redis支持数据的备份，即master-slave模式的数据备份。</li></ul><h2 id="Redis的应用场景"><a href="#Redis的应用场景" class="headerlink" title="Redis的应用场景"></a>Redis的应用场景</h2><ul><li>缓存，提升性能的常用方式</li><li>排行榜系统，Redis提供了列表和有序集合数据结构</li><li>计数器应用</li><li>消息队列系统，Redis 发布订阅(pub/sub)是一种消息通信模式：发送者(pub)发送消息，订阅者(sub)接收消息。</li></ul><h2 id="安装Redis"><a href="#安装Redis" class="headerlink" title="安装Redis"></a>安装Redis</h2><pre><code># mac    &gt; brew install redis# ubuntu    &gt; apt-get install redis# redhat    &gt; yum install redis# 运行客户端    &gt; redis-cli</code></pre><h2 id="Redis数据类型"><a href="#Redis数据类型" class="headerlink" title="Redis数据类型"></a>Redis数据类型</h2><p>Redis支持五种数据类型：string（字符串），hash（哈希），list（列表），set（集合）及zset(sorted set：有序集合)。</p><h4 id="String（字符串）"><a href="#String（字符串）" class="headerlink" title="String（字符串）"></a>String（字符串）</h4><p>string是redis最基本的类型，你可以理解成与Memcached一模一样的类型，一个key对应一个value。字符串类型的值实际可以<br>是字符串（简单的字符串、复杂的字符串（例如JSON、XML））、数字（整数、浮点数），甚至是二进制（图片、音频、视频），但是值最大不能<br>超过512MB。</p><pre><code> redis 127.0.0.1:6379&gt; SET name godfery OK redis 127.0.0.1:6379&gt; GET name &quot;godfery&quot;</code></pre><h4 id="Hash（哈希）"><a href="#Hash（哈希）" class="headerlink" title="Hash（哈希）"></a>Hash（哈希）</h4><p>Redis hash 是一个 string 类型的 field 和 value 的映射表，hash 特别适合用于存储对象。</p><pre><code> redis&gt; HMSET myhash name godfery age 26 &quot;OK&quot; redis&gt; HGET myhash name &quot;godfery&quot;</code></pre><h4 id="List（列表）"><a href="#List（列表）" class="headerlink" title="List（列表）"></a>List（列表）</h4><p>Redis 列表是简单的字符串列表，按照插入顺序排序。你可以添加一个元素到列表的头部（左边）或者尾部（右边）。</p><pre><code> redis 127.0.0.1:6379&gt; lpush mylist java (integer) 1 redis 127.0.0.1:6379&gt; lpush mylist python (integer) 2 redis 127.0.0.1:6379&gt; lpush mylist ruby (integer) 3 redis 127.0.0.1:6379&gt; lrange mylist 0 10    1) &quot;ruby&quot;    2) &quot;python&quot;    3) &quot;java&quot;</code></pre><h4 id="Set（集合）"><a href="#Set（集合）" class="headerlink" title="Set（集合）"></a>Set（集合）</h4><p>Redis的Set是string类型的无序集合。<br>sadd 命令添加一个 string 元素到 key 对应的 set 集合中，成功返回1，如果元素已经在集合中返回 0，如果 key 对应的 set 不存在则返回错误。</p><pre><code>  redis 127.0.0.1:6379&gt; sadd myset redis (integer) 1 redis 127.0.0.1:6379&gt; sadd myset java (integer) 1 redis 127.0.0.1:6379&gt; sadd myset java (integer) 0</code></pre><h4 id="zset-sorted-set：有序集合"><a href="#zset-sorted-set：有序集合" class="headerlink" title="zset(sorted set：有序集合)"></a>zset(sorted set：有序集合)</h4><p>Redis zset 和 set 一样也是string类型元素的集合,且不允许重复的成员。<br>不同的是每个元素都会关联一个double类型的分数。redis正是通过分数来为集合中的成员进行从小到大的排序。  </p><pre><code> zadd key score member </code></pre><h2 id="持久化"><a href="#持久化" class="headerlink" title="持久化"></a>持久化</h2><h4 id="RDB"><a href="#RDB" class="headerlink" title="RDB"></a>RDB</h4><p>RDB持久化是把当前进程数据生成快照保存到硬盘的过程，触发RDB持<br>久化过程分为手动触发和自动触发。</p><h6 id="手动触发"><a href="#手动触发" class="headerlink" title="手动触发"></a>手动触发</h6><p>-save命令： 阻塞当前Redis服务器，直到RDB过程完成为止，对于内存<br>比较大的实例会造成长时间阻塞，线上环境不建议使用。</p><pre><code>    redis 127.0.0.1:6379&gt; SAVE    OK</code></pre><p>执行save会在 redis 安装目录中创建dump.rdb文件。</p><ul><li>bgsave命令： Redis进程执行fork操作创建子进程，RDB持久化过程由子<br>进程负责，完成后自动结束。阻塞只发生在fork阶段，一般时间很短。</li></ul><p>bgsave的运行流程</p><p><img src="https://i.loli.net/2019/09/04/WFqxG7Q5I4REiNp.png" alt="redis1.png"></p><ul><li>1.执行bgsave命令，Redis父进程判断当前是否存在正在执行的子进<br>程，如RDB/AOF子进程，如果存在bgsave命令直接返回</li><li>2）父进程执行fork操作创建子进程，fork操作过程中父进程会阻塞，通<br>过info stats命令查看latest_fork_usec选项，可以获取最近一个fork操作的耗<br>时，单位为微秒。</li><li>3）父进程fork完成后，bgsave命令返回“Background saving started”信息<br>并不再阻塞父进程，可以继续响应其他命令。</li><li>4）子进程创建RDB文件，根据父进程内存生成临时快照文件，完成后<br>对原有文件进行原子替换。执行lastsave命令可以获取最后一次生成RDB的<br>时间，对应info统计的rdb_last_save_time选项。</li><li>5）进程发送信号给父进程表示完成，父进程更新统计信息，具体见<br>info Persistence下的rdb_*相关选项。</li></ul><h5 id="自动触发RDB的持久化机制"><a href="#自动触发RDB的持久化机制" class="headerlink" title="自动触发RDB的持久化机制"></a>自动触发RDB的持久化机制</h5><p>Redis内部还存在自动触发RDB的持久化机制，以下场景会自动触发RDB</p><ul><li>使用save相关配置，如“save m n”。表示m秒内数据集存在n次修改<br>时，自动触发bgsave。</li><li>如果从节点执行全量复制操作，主节点自动执行bgsave生成RDB文件并发送给从节点</li><li>执行debug reload命令重新加载Redis时，也会自动触发save操作</li><li>默认情况下执行shutdown命令时，如果没有开启AOF持久化功能则<br>自动执行bgsave</li></ul><h4 id="AOF"><a href="#AOF" class="headerlink" title="AOF"></a>AOF</h4><p>以独立日志的方式记录每次写命令，<br>重启时再重新执行AOF文件中的命令达到恢复数据的目的。AOF解决了Redis数据持久化的实时性问题，是目前主流的持久化方式。</p><h6 id="AOF的流程"><a href="#AOF的流程" class="headerlink" title="AOF的流程"></a>AOF的流程</h6><p>AOF的工作流程操作：命令写入<br>（append）、文件同步（sync）、文件重写（rewrite）、重启加载<br>（load）<br><img src="https://i.loli.net/2019/09/05/UbHkgNEIzf68jLK.png" alt="redis2.png"></p><ul><li>1）所有的写入命令会追加到aof_buf（缓冲区）中。</li><li>2）AOF缓冲区根据对应的策略向硬盘做同步操作。</li><li>3）随着AOF文件越来越大，需要定期对AOF文件进行重写，达到压缩<br>的目的。</li><li>4）当Redis服务器重启时，可以加载AOF文件进行数据恢复。</li></ul>]]></content>
      
      
      <categories>
          
          <category> Redis </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Redis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>新一代构建工具Gradle</title>
      <link href="/2018/01/03/Gradle/"/>
      <url>/2018/01/03/Gradle/</url>
      
        <content type="html"><![CDATA[<h2 id="项目自动化介绍"><a href="#项目自动化介绍" class="headerlink" title="项目自动化介绍"></a>项目自动化介绍</h2><p>石器时代：在没有构建工具之前</p><ul><li>依赖管理 将依赖的jar包放在lib目录下</li><li>测试 能不写就不写</li><li>打包 通过ide打包</li><li>上传  ftp上传到服务器</li></ul><h2 id="构建工具"><a href="#构建工具" class="headerlink" title="构建工具"></a>构建工具</h2><p>依赖管理<br>测试 打包 发布</p><p>主流的构建工具<br>ant 编译，测试，打包<br>maven 依赖管理 发布<br>gradle 在maven的基础上通过Groovy管理构建脚本</p><h2 id="Gradle是什么"><a href="#Gradle是什么" class="headerlink" title="Gradle是什么"></a>Gradle是什么</h2><p>  一个开源的项目自动化构建工具，建立在Apache Ant和Apache Maven概念的基础之上，并引入了基于Groovy的特定领域语言(DSL)，而不再是使用XML形式管理构建脚本</p><p>Gradle 安装</p><ul><li>确保已经安装了JDK， Java -version</li><li>从Gradle官网下载Grande，<a href="https://gradle.org" target="_blank" rel="noopener">https://gradle.org</a></li><li>下载后解压到任意目录，配置环境变量GRADLE_HOME</li><li>添加到path，%GRADLE_HOME%\bin;</li><li>验证 gradle -v</li></ul>]]></content>
      
      
      <categories>
          
          <category> Gradle </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Gradle </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java NIO 简述</title>
      <link href="/2017/12/26/Java%20NIO/"/>
      <url>/2017/12/26/Java%20NIO/</url>
      
        <content type="html"><![CDATA[<h2 id="Java-NIO"><a href="#Java-NIO" class="headerlink" title="Java NIO"></a>Java NIO</h2><h4 id="Java-NIO-简介"><a href="#Java-NIO-简介" class="headerlink" title="Java NIO 简介"></a>Java NIO 简介</h4><p>Java NIO（New IO）是从Java 1.4版本开始引入的一个新的IO API，可以替代标准的Java IO API。NIO与原来的IO有同样的作用和目的，但是使用的方式完全不同，NIO支持面向缓冲区的、基于通道的IO操作。NIO将以更加高效的方式进行文件的读写操作。</p><h4 id="Java-NIO-与-IO-的主要区别"><a href="#Java-NIO-与-IO-的主要区别" class="headerlink" title="Java NIO  与 IO  的主要区别"></a>Java NIO  与 IO  的主要区别</h4><table><thead><tr><th>IO</th><th>NIO</th></tr></thead><tbody><tr><td>面向流(Stream Oriented)</td><td>面向缓冲区(Buffer Oriented)</td></tr><tr><td>阻塞IO(Blocking IO)</td><td>非阻塞IO(Non Blocking IO)</td></tr></tbody></table><h4 id="缓冲区-Buffer-和通道-Channel"><a href="#缓冲区-Buffer-和通道-Channel" class="headerlink" title="缓冲区(Buffer)和通道(Channel)"></a>缓冲区(Buffer)和通道(Channel)</h4><p>Java NIO系统的核心在于：通道(Channel)和缓冲区(Buffer)。通道表示打开到 IO 设备(例如：文件、套接字)的连接。若需要使用 NIO 系统，需要获取用于连接 IO设备的通道以及用于容纳数据的缓冲区。然后操作缓冲区，对数据进行处理。简而言之，Channel  负责传输， Buffer 负责存储</p><h6 id="缓冲区Buffer"><a href="#缓冲区Buffer" class="headerlink" title="缓冲区Buffer"></a>缓冲区Buffer</h6><p> 一个用于特定基本数据类型的容器。由 java.nio包定义的，所有缓冲区都是 Buffer 抽象类的子类。Java NIO 中的 Buffer 主要用于与 NIO 通道进行交互，数据是从通道读入缓冲区，从缓冲区写入通道中的</p><p> Buffer 就像一个数组，可以保存多个相同类型的数据。根据数据类型不同(boolean 除外) ，有以下 Buffer 常用子类：</p><ul><li>ByteBuffer</li><li>CharBuffer</li><li>ShortBuffer</li><li>IntBuffer</li><li>LongBuffer</li><li>FloatBuffer</li><li>DoubleBuffer</li></ul><p>上述 Buffer 类 他们都采用相似的方法进行管理数据，只是各自管理的数据类型不同而已。都是通过如下方法获取一个 Buffer对象：</p><pre><code>allocate(int capacity) : 创建一个容量为capacity 的 XxxBuffer 对象</code></pre><h5 id="缓冲区的基本属性"><a href="#缓冲区的基本属性" class="headerlink" title="缓冲区的基本属性"></a>缓冲区的基本属性</h5><h6 id="Buffer-中的重要概念："><a href="#Buffer-中的重要概念：" class="headerlink" title="Buffer 中的重要概念："></a>Buffer 中的重要概念：</h6><ul><li>容量 (capacity)  ：表示 Buffer 最大数据容量，缓冲区容量不能为负，并且创建后不能更改。</li><li>限制 (limit) ：第一个不应该读取或写入的数据的索引，即位于 limit 后的数据<br>不可读写。缓冲区的限制不能为负，并且不能大于其容量。</li><li>位置 (position)： 下一个要读取或写入的数据的索引。缓冲区的位置不能为负，并且不能大于其限制</li><li>标记 (mark) 与重置 (reset) ：标记是一个索引，通过 Buffer 中的 mark() 方法<br>指定 Buffer 中一个特定的 position，之后可以通过调用 reset() 方法恢复到这个 position.</li></ul><pre><code>标记 、 位置 、 限制 、 容量遵守以下不变式： 0 &lt;= mark &lt;= position &lt;= limit &lt;= capacity</code></pre><p><img src="http://omtagtyxe.bkt.clouddn.com/nio1.png" alt=""></p><table><thead><tr><th>Method</th><th>Description</th></tr></thead><tbody><tr><td>Buffer  clear()</td><td>清空缓冲区并返回对缓冲区的引用</td></tr><tr><td>Buffer flip()</td><td>将缓冲区的界限设置为当前位置，并将当前位置充值为 0 0</td></tr><tr><td>int capacity()</td><td>返回 Buffer 的 capacity 大小</td></tr><tr><td>boolean hasRemaining()</td><td>判断缓冲区中是否还有元素</td></tr><tr><td>int limit()</td><td>返回 Buffer 的界限(limit) 的位置</td></tr><tr><td>Buffer limit(int n)</td><td>将设置缓冲区界限为 n, 并返回一个具有新 limit 的缓冲区对象</td></tr><tr><td>Buffer mark()</td><td>对缓冲区设置标记</td></tr><tr><td>int position()</td><td>返回缓冲区的当前位置 position</td></tr><tr><td>Buffer position(int n)</td><td>将设置缓冲区的当前位置为 n , 并返回修改后的 Buffer 对象</td></tr><tr><td>int remaining()</td><td>返回 position 和 limit 之间的元素个数</td></tr><tr><td>Buffer reset()</td><td>将位置 position 转到以前设置的 mark 所在的位置</td></tr><tr><td>Buffer rewind()</td><td>将位置设为为 0， 取消设置的 mark</td></tr></tbody></table><h6 id="缓冲区的数据操作"><a href="#缓冲区的数据操作" class="headerlink" title="缓冲区的数据操作"></a>缓冲区的数据操作</h6><p> Buffer 所有子类提供了两个用于数据操作的方法：get()与 put() 方法</p><ul><li>获取 Buffer  中的数据<ul><li>get() ：读取单个字节</li><li>get(byte[] dst)：批量读取多个字节到dst 中</li><li>get(int index)：读取指定索引位置的字节(不会移动 position)</li></ul></li><li>放到入数据到Buffer中 <ul><li>put(byte b)：将给定单个字节写入缓冲区的当前位置</li><li>put(byte[] src)：将 src 中的字节写入缓冲区的当前位置</li><li>put(int index, byte b)：将指定字节写入缓冲区的索引位置(不会移动 position)</li></ul></li></ul><pre class="line-numbers language-Java"><code class="language-Java">String str = "abcdefg";        //1.分配一个指定大小的缓冲区        ByteBuffer buf = ByteBuffer.allocate(1024);        System.out.println("----------allocate()------------");        System.out.println(buf.position());        System.out.println(buf.limit());        System.out.println(buf.capacity());        //2.存入数据到缓存区、        buf.put(str.getBytes());        System.out.println("----------put()------------");        System.out.println(buf.position());        System.out.println(buf.limit());        System.out.println(buf.capacity());        //3.切换到读取数据的模式        buf.flip();        System.out.println("----------get()------------");        System.out.println(buf.position());        System.out.println(buf.limit());        System.out.println(buf.capacity());        //4.利用get方法读取数据        byte[] dst = new byte[buf.limit()];        buf.get(dst);        System.out.println(new String(dst, 0, dst.length));        System.out.println(buf.position());        System.out.println(buf.limit());        System.out.println(buf.capacity());        buf.rewind();        System.out.println("----------rewind() 可重复读------------");        System.out.println(buf.position());        System.out.println(buf.limit());        System.out.println(buf.capacity());        buf.clear();        System.out.println("----------clear() 清空缓冲区 " +                "但是缓冲区的数据依然存在，只是出于“被遗忘状态”-指针恢复到最初状态-----------");        System.out.println(buf.position());        System.out.println(buf.limit());        System.out.println(buf.capacity());        System.out.println((char)buf.get());----------allocate()------------010241024----------put()------------710241024----------get()------------071024abcdefg771024----------rewind() 可重复读------------071024----------clear() 清空缓冲区 但是缓冲区的数据依然存在，只是出于“被遗忘状态”-指针恢复到最初状态-----------010241024aad25bcd210<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h6 id="Channel-（通道）"><a href="#Channel-（通道）" class="headerlink" title="Channel （通道）"></a>Channel （通道）</h6><ul><li><p>Channel用于源节点与目标节点的连接，负责Java NIO中缓冲区的数据传输，Channel本身不存储数据，需要配合Buffer进行传输。</p></li><li><p>主要的实现类 FileChannel SocketChannel ServerSocketChannel DatagramChannel</p></li><li><p>获取通道的方法：java针对支持Channel的类提供了getChannel()方法，jdk1.7中提供了静态方法open(), Files工具类提供了newByteChannal();</p><pre class="line-numbers language-Java"><code class="language-Java">  //getChannel()方法获取  FileInputStream fis = new FileInputStream("D:\\电子书\\Java 8实战.pdf");  Channel channel = fis.getChannel();  //open()  FileChannel.open(Paths.get("D:\\电子书\\Java 8实战.pdf"), StandardOpenOption.WRITE);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>Channel的write方法用于将buffer的数据写入到channel中，read方法用于将channel的数据读取到buffer中。<br>举个例子，Channel+ByteBuffer实现文件拷贝</p><pre class="line-numbers language-Java"><code class="language-Java">//获取通道      FileChannel readChannel = null;      FileChannel writeChannel = null;      readChannel = new FileInputStream("D:\\电子书\\阿里巴巴Java开发手册v1.2.0.pdf").getChannel();      writeChannel = new FileOutputStream("D:\\电子书\\阿里巴巴Java开发手册v1.2.0_bak.pdf").getChannel();      //缓冲区分配      ByteBuffer buffer = ByteBuffer.allocate(1024);      //将通道中的数据读入缓冲区      while(readChannel.read(buffer)!=-1){          buffer.flip();          //将缓冲区的数据写入通道          writeChannel.write(buffer);          buffer.clear();      }<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h6 id="内存映射文件-MappedByteBuffer"><a href="#内存映射文件-MappedByteBuffer" class="headerlink" title="内存映射文件 MappedByteBuffer"></a>内存映射文件 MappedByteBuffer</h6></li></ul><p>操作系统的内存分两部分:</p><ul><li>物理内存（即内存条的内存空间）;</li><li>虚拟内存.虚拟内存一般使用的是页面映像文件,即硬盘中的某些特殊的文件.计算机系统内存管理的一种技术。它使得应用程序认为它拥有连续的可用的内存（一个连续完整的地址空间），而实际上，它通常是被分隔成多个物理内存碎片，还有部分暂时存储在外部磁盘存储器上，在需要时进行数据交换。</li><li>缺页中断：当程序试图访问已映射在虚拟地址空间中但未被加载至物理内存的一个分页时，由MMC（CPU的内存管理单元）发出的中断。如果操作系统判断此次访问是有效的，则尝试将相关的页从虚拟内存文件中载入物理内存。</li></ul><p>MappedByteBuffer使用的是mmap技术。MappedByteBuffer将文件映射为内存，也可能会被存储在虚拟内存里面，访问的时候通过缺页机制调进内存。</p><p>FileChannel提供了map方法获取MappedByteBuffer,可以指定访问的位置，访问内存映射文件的方式，其中，访问内存映射文件的方式有3种，分别为：READ_ONLY（只读），READ_WRITE（读写），PRIVATE（专用）。采用内存映射文件可以很大的提高读写文件的效率，因为将直接访问系统内存。</p><pre class="line-numbers language-Java"><code class="language-Java">        FileChannel readChannel = FileChannel.open(Paths.get("D:\\电子书\\阿里巴巴Java开发手册v1.2.0.pdf"), StandardOpenOption.READ);        FileChannel writeChannel = FileChannel.open(Paths.get("D:\\电子书\\阿里巴巴Java开发手册v1.2.0_bak2.pdf"),                StandardOpenOption.WRITE, StandardOpenOption.CREATE, StandardOpenOption.READ);        MappedByteBuffer readMapperByteBuffer = readChannel.map(MapMode.READ_ONLY, 0, readChannel.size());        MappedByteBuffer writerMappedByteBuffer = writeChannel.map(MapMode.READ_WRITE, 0, readChannel.size());        byte[] dst = new byte[readMapperByteBuffer.limit()];        readMapperByteBuffer.get(dst);        writerMappedByteBuffer.put(dst);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h6 id="Pipe"><a href="#Pipe" class="headerlink" title="Pipe"></a>Pipe</h6><ul><li>Java NIO 管道是2个线程之间的单向数据连接。Pipe有一个source通道和一个sink通道。数据会被写到sink通道，从source通道读取.</li></ul><pre class="line-numbers language-Java"><code class="language-Java">        //获取pipe        Pipe pipe = Pipe.open();        //分配缓存区        ByteBuffer byteBuffer = ByteBuffer.allocate(1024);        //数据从sink通道写入        Pipe.SinkChannel sinkChannel = pipe.sink();        byteBuffer.put("通过Pipe发送数据".getBytes());        byteBuffer.flip();        sinkChannel.write(byteBuffer);        //从source通道读取        Pipe.SourceChannel sourceChannel = pipe.source();        byteBuffer.flip();        int len = sourceChannel.read(byteBuffer);        System.out.println(new String(byteBuffer.array(), 0, len));        sourceChannel.close();        sinkChannel.close();<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h6 id="Selector"><a href="#Selector" class="headerlink" title="Selector"></a>Selector</h6><p>Selector（选择器）是Java NIO中能够检测一到多个NIO通道，并能够知晓通道是否为诸如读写事件做好准备的组件。这样，一个单独的线程可以管理多个channel，从而管理多个网络连接。</p><ul><li><p>Selector的创建</p><pre><code>  Selector selector = Selector.open();</code></pre></li><li><p>向Selector注册通道</p><pre><code>channel.configureBlocking(false);//切换成非阻塞模式SelectionKey key = channel.register(selector,  Selectionkey.OP_READ);</code></pre></li><li><p>SelectionKey<br>当向Selector注册Channel时，register()方法会返回一个SelectionKey对象</p></li><li><p>select()方法<br>Selector注册了一或多个通道，就可以调用几个重载的select()方法。这些方法返回你所感兴趣的事件（如连接、接受、读或写）已经准备就绪的那些通道，<br>select()方法返回的int值表示有多少通道已经就绪。</p><p>  <code>`</code>Java</p><pre><code>  //获取通道  ServerSocketChannel channel = ServerSocketChannel.open();  //绑定连接  channel.bind(new InetSocketAddress(8888));  //创建Selector  Selector selector = Selector.open();  //非阻塞模式  channel.configureBlocking(false);  //将channel注册到Selector上  SelectionKey key = channel.register(selector, SelectionKey.OP_ACCEPT);  //轮询获取selector上的就绪事件  while(true) {    int readyChannels = selector.select();    if(readyChannels == 0) continue;    Set&lt;SelectionKey&gt; selectedKeys = selector.selectedKeys();    Iterator&lt;SelectionKey&gt; keyIterator = selectedKeys.iterator();    while(keyIterator.hasNext()) {      SelectionKey key = keyIterator.next();      if(key.isAcceptable()) {          // a connection was accepted by a ServerSocketChannel.      } else if (key.isConnectable()) {          // a connection was established with a remote server.      } else if (key.isReadable()) {          // a channel is ready for reading      } else if (key.isWritable()) {          // a channel is ready for writing      }      keyIterator.remove();    }  }</code></pre></li></ul><p><code>`</code></p>]]></content>
      
      
      <categories>
          
          <category> Java NIO </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> NIO </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>《Java 8 实战》读书笔记</title>
      <link href="/2017/12/26/Java8/"/>
      <url>/2017/12/26/Java8/</url>
      
        <content type="html"><![CDATA[<h1 id="本章内容"><a href="#本章内容" class="headerlink" title="本章内容"></a>本章内容</h1><h2 id="Java怎么又变了"><a href="#Java怎么又变了" class="headerlink" title="Java怎么又变了"></a>Java怎么又变了</h2><p>  Java 8所做的改变，在许多方面比Java历史上任何一次改变深远。而且好<br>消息是，这些改变会让你编起程来更容易，用不着再写类似下面这种啰嗦的程序了（对inventory<br>中的苹果按照重量进行排序）：</p><pre class="line-numbers language-java"><code class="language-java">    Collections<span class="token punctuation">.</span><span class="token function">sort</span><span class="token punctuation">(</span>inventory<span class="token punctuation">,</span> <span class="token keyword">new</span> <span class="token class-name">Comparator</span><span class="token operator">&lt;</span>Apple<span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>       <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">compare</span><span class="token punctuation">(</span>Apple a1<span class="token punctuation">,</span> Apple a2<span class="token punctuation">)</span><span class="token punctuation">{</span>         <span class="token keyword">return</span> a1<span class="token punctuation">.</span><span class="token function">getWeight</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">compareTo</span><span class="token punctuation">(</span>a2<span class="token punctuation">.</span><span class="token function">getWeight</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token punctuation">}</span>     <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在Java 8里面，你可以编写更为简洁的代码，这些代码读起来更接近问题的描述：</p><pre><code> inventory.sort(comparing(Apple::getWeight));</code></pre><h2 id="Java中的函数"><a href="#Java中的函数" class="headerlink" title="Java中的函数"></a>Java中的函数</h2><p>Java 8中新增了函数——值的一种新形式。 借助于Stream API，Java 8可以进行多核处理器上的并行编程。</p><p>第一个例子中介绍了Java8的新功能方法引用,比方说，你想要筛选一个目录中的所有隐藏文件。</p><pre><code>File[] hiddenFiles = new File(&quot;.&quot;).listFiles(new FileFilter() {      public boolean accept(File file) {      return file.isHidden();     } }); </code></pre><p>在Java 8里，你可以把代码重写成这个样子：哇！酷不酷？你已经有了函数isHidden，因此只需用Java 8的方法引用::语法（即“把这<br>个方法作为值”）将其传给listFiles方法；</p><pre><code> File[] hiddenFiles = new File(&quot;.&quot;).listFiles(File::isHidden);</code></pre><h2 id="流"><a href="#流" class="headerlink" title="流"></a>流</h2><p> Java8之前操作集合<br>比方说，你需要<br>从一个列表中筛选金额较高的交易，然后按货币分组。</p><pre><code>Map&lt;Currency, List&lt;Transaction&gt;&gt;     transactionsByCurrencies =  new HashMap&lt;&gt;();     for (Transaction transaction : transactions) {       if(transaction.getPrice() &gt; 1000){        Currency currency = transaction.getCurrency();         List&lt;Transaction&gt; transactionsForCurrency =                  transactionsByCurrencies.get(currency);     if (transactionsForCurrency == null) {     transactionsForCurrency = new ArrayList&lt;&gt;();     transactionsByCurrencies.put(currency,      transactionsForCurrency);     }  transactionsForCurrency.add(transaction);  } } </code></pre><p> 有了Stream API</p><pre><code>import static java.util.stream.Collectors.toList;   Map&lt;Currency, List&lt;Transaction&gt;&gt; transactionsByCurrencies =     transactions.stream()      .filter((Transaction t) -&gt; t.getPrice() &gt; 1000)         .collect(groupingBy(Transaction::getCurrency)   );</code></pre><h2 id="默认方法"><a href="#默认方法" class="headerlink" title="默认方法"></a>默认方法</h2><p>接口中可以有方法的实现了，在Java 8里，你现在可以直接对List调用sort方法。它是用Java 8 List接口中如下所<br>示的默认方法实现的，它会调用Collections.sort静态方法：</p><pre><code>default void sort(Comparator&lt;? super E&gt; c) {  Collections.sort(this, c); } </code></pre><h1 id="流的概念，与集合的异同"><a href="#流的概念，与集合的异同" class="headerlink" title="流的概念，与集合的异同"></a>流的概念，与集合的异同</h1><h2 id="流是什么"><a href="#流是什么" class="headerlink" title="流是什么"></a>流是什么</h2><ul><li><p>流是Java API的新成员，它允许你以声明性方式处理数据集合（通过查询语句来表达，而不<br>是临时编写一个实现）。可以把它们看成遍历数据集的高级迭代器。</p></li><li><p>作者在第一章中举了一个实际的例子：Unix的cat命令会把两个文件连接起来创建一个流，tr会转换流中的<br>字符，sort会对流中的行进行排序，而tail -3则给出流的最后三行。Unix命令行允许这些程<br>序通过管道（|）连接在一起，比如</p><p>  cat file1 file2 | tr “[A-Z]” “[a-z]” | sort | tail -3</p><p> 会（假设file1和file2中每行都只有一个词）先把字母转换成小写字母，然后打印出按照词典<br>排序出现在最后的三个单词。我们说sort把一个行流①作为输入，产生了另一个行流（进行排<br>序）作为输出。<br><img src="https://s1.ax2x.com/2017/12/26/YM8eu.png" alt=""></p></li><li><p>Stream API就是基于这种思想设计的。</p></li><li>使用流的好处：<br>下面两段代码都是用来返回低热量的菜肴名称的，<br>并按照卡路里排序。</li><li>Java7：用了一个“垃圾变量”lowCaloricDishes。它唯一的作用就是作为一次<br>性的中间容器。<pre class="line-numbers language-java"><code class="language-java">   List<span class="token operator">&lt;</span>Dish<span class="token operator">></span> lowCaloricDishes <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>       <span class="token keyword">for</span><span class="token punctuation">(</span>Dish d<span class="token operator">:</span> menu<span class="token punctuation">)</span><span class="token punctuation">{</span>       <span class="token keyword">if</span><span class="token punctuation">(</span>d<span class="token punctuation">.</span><span class="token function">getCalories</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;</span> <span class="token number">400</span><span class="token punctuation">)</span><span class="token punctuation">{</span>       lowCaloricDishes<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>d<span class="token punctuation">)</span><span class="token punctuation">;</span>       <span class="token punctuation">}</span>     <span class="token punctuation">}</span>       Collections<span class="token punctuation">.</span><span class="token function">sort</span><span class="token punctuation">(</span>lowCaloricDishes<span class="token punctuation">,</span> <span class="token keyword">new</span> <span class="token class-name">Comparator</span><span class="token operator">&lt;</span>Dish<span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>          <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">compare</span><span class="token punctuation">(</span>Dish d1<span class="token punctuation">,</span> Dish d2<span class="token punctuation">)</span><span class="token punctuation">{</span>           <span class="token keyword">return</span> Integer<span class="token punctuation">.</span><span class="token function">compare</span><span class="token punctuation">(</span>d1<span class="token punctuation">.</span><span class="token function">getCalories</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> d2<span class="token punctuation">.</span><span class="token function">getCalories</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>           <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>     List<span class="token operator">&lt;</span>String<span class="token operator">></span> lowCaloricDishesName <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token keyword">for</span><span class="token punctuation">(</span>Dish d<span class="token operator">:</span> lowCaloricDishes<span class="token punctuation">)</span><span class="token punctuation">{</span>      lowCaloricDishesName<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>d<span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token punctuation">}</span> <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li>Java8:<pre class="line-numbers language-java"><code class="language-java">  <span class="token keyword">import</span> <span class="token keyword">static</span> java<span class="token punctuation">.</span>util<span class="token punctuation">.</span>Comparator<span class="token punctuation">.</span>comparing<span class="token punctuation">;</span>   <span class="token keyword">import</span> <span class="token keyword">static</span> java<span class="token punctuation">.</span>util<span class="token punctuation">.</span>stream<span class="token punctuation">.</span>Collectors<span class="token punctuation">.</span>toList<span class="token punctuation">;</span>   List<span class="token operator">&lt;</span>String<span class="token operator">></span> lowCaloricDishesName <span class="token operator">=</span>    menu<span class="token punctuation">.</span><span class="token function">stream</span><span class="token punctuation">(</span><span class="token punctuation">)</span>  <span class="token comment" spellcheck="true">//从menu获得流（菜肴列表）</span>   <span class="token punctuation">.</span><span class="token function">filter</span><span class="token punctuation">(</span>d <span class="token operator">-</span><span class="token operator">></span> d<span class="token punctuation">.</span><span class="token function">getCalories</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;</span> <span class="token number">400</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true">//首先选出低热量的菜肴</span>   <span class="token punctuation">.</span><span class="token function">sorted</span><span class="token punctuation">(</span><span class="token function">comparing</span><span class="token punctuation">(</span>Dish<span class="token operator">:</span><span class="token operator">:</span>getCalories<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true">//排序</span>   <span class="token punctuation">.</span><span class="token function">map</span><span class="token punctuation">(</span>Dish<span class="token operator">:</span><span class="token operator">:</span>getName<span class="token punctuation">)</span> <span class="token comment" spellcheck="true">//获取菜名</span>   <span class="token punctuation">.</span><span class="token function">collect</span><span class="token punctuation">(</span><span class="token function">toList</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>-将流操作链接起来构成流的流水线<br><img src="https://s1.ax2x.com/2017/12/26/YO3ei.png" alt=""></li></ul><p>-那么，流到底是什么呢？简短的定义就是“<strong>从支持数据处理操作的源生成的元素序列</strong>”。</p><h3 id="流只能消费一次"><a href="#流只能消费一次" class="headerlink" title="流只能消费一次"></a>流只能消费一次</h3><blockquote><p>迭代器类似，流只能遍历一次。遍历完之后，我们就说这个流已经被消费掉了。你可以从原始数据源那里再获得一个新的流来重新遍历一遍</p></blockquote><pre><code>List&lt;String&gt; title = Arrays.asList(&quot;Java8&quot;, &quot;In&quot;, &quot;Action&quot;); Stream&lt;String&gt; s = title.stream();  s.forEach(System.out::println); //打印标题中的每个单词 s.forEach(System.out::println);    //java.lang.IllegalStateException:流已被操作或关闭</code></pre><h3 id="外部迭代与内部迭代"><a href="#外部迭代与内部迭代" class="headerlink" title="外部迭代与内部迭代"></a>外部迭代与内部迭代</h3><blockquote><p>使用Collection接口需要用户去做迭代（比如用for-each），这称为外部迭代。 相反，Streams库使用内部迭代。</p></blockquote><h3 id="流的操作"><a href="#流的操作" class="headerlink" title="流的操作"></a>流的操作</h3><ul><li><strong>中间操作</strong> 和  <strong>终端操作</strong></li></ul><pre><code> List&lt;String&gt; names = menu.stream()  .filter(d -&gt; d.getCalories() &gt; 300) .map(Dish::getName)  .limit(3)  .collect(toList());</code></pre><ul><li>filter、map和limit可以连成一条流水线  （中间操作）</li><li>collect触发流水线执行并关闭它  （终端操作）</li></ul><blockquote><p>总而言之，流的使用一般包括三件事：<br>  一个数据源（如集合）来执行一个查询；<br>  一个中间操作链，形成一条流的流水线；<br>  一个终端操作，执行流水线，并能生成结果。</p></blockquote><h1 id="使用流实现达复杂数据处理查询"><a href="#使用流实现达复杂数据处理查询" class="headerlink" title="使用流实现达复杂数据处理查询"></a>使用流实现达复杂数据处理查询</h1><h2 id="筛选和切片"><a href="#筛选和切片" class="headerlink" title="筛选和切片"></a>筛选和切片</h2><ul><li><p>filter方法（你现在应该很熟悉了）。该操作会接受一个谓词（一个返回<br>boolean的函数）作为参数，并返回一个包括所有符合谓词的元素的流</p><pre><code>  List&lt;Dish&gt; vegetarianMenu = menu.stream()   .filter(Dish::isVegetarian)   .collect(toList());</code></pre></li><li><p>流还支持一个叫作<strong>distinct</strong>的方法，它会返回一个元素各异（根据流所生成元素的<br>hashCode和equals方法实现）的流。也就是去重。</p></li><li><p>流支持<strong>limit(n)</strong>方法，该方法会返回一个不超过给定长度的流。所需的长度作为参数传递<br>给limit。如果流是有序的，则最多会返回前n个元素。</p></li><li><p>流还支持<strong>skip(n)</strong>方法，返回一个扔掉了前n个元素的流。如果流中元素不足n个，则返回一<br>个空流。</p></li></ul><h2 id="映射"><a href="#映射" class="headerlink" title="映射"></a>映射</h2><ul><li><p>流支持map方法，它会接受一个函数作为参数。这个函数会被应用到每个元素上，并将其映射成一个新的元素。</p><p>   List<string> dishNames = menu.stream() </string></p><pre><code>  .map(Dish::getName) //提取流中菜肴的名称  .collect(toList()); </code></pre></li></ul><p>map 生成的是个 1:1 映射，每个输入元素，都按照规则转换成为另外一个元素。还有一些场景，是一对多映射关系的，这时需要 <strong>flatMap</strong>。</p><pre><code> Stream&lt;List&lt;Integer&gt;&gt; inputStream = Stream.of(    Arrays.asList(1),    Arrays.asList(2, 3),    Arrays.asList(4, 5, 6)    );    Stream&lt;Integer&gt; outputStream = inputStream.    flatMap((childList) -&gt; childList.stream());</code></pre><ul><li>flatMap 把 input Stream 中的层级结构扁平化，就是将最底层元素抽出来放到一起，最终 output 的新 Stream 里面已经没有 List 了，都是直接的数字。</li></ul><h2 id="查找和匹配"><a href="#查找和匹配" class="headerlink" title="查找和匹配"></a>查找和匹配</h2><ul><li><p><strong>anyMatch</strong>是否至少匹配一个元素</p><pre><code>//看菜单里面是否有素食if(menu.stream().anyMatch(Dish::isVegetarian)){ System.out.println(&quot;The menu is (somewhat) vegetarian friendly!!&quot;); } </code></pre><p>anyMatch方法返回一个boolean，因此是一个终端操作。</p></li><li><p><strong>allMatch</strong>是否匹配所有元素</p></li></ul><pre><code>    //来看看菜品是否有利健康（即所有菜的热量都低于1000卡路里）   boolean isHealthy = menu.stream()      .allMatch(d -&gt; d.getCalories() &lt; 1000); </code></pre><ul><li><strong>noneMatch</strong><br>和allMatch相对的是noneMatch</li></ul><h2 id="查找元素"><a href="#查找元素" class="headerlink" title="查找元素"></a>查找元素</h2><ul><li><strong>findAny</strong>方法将返回当前流中的任意元素。它可以与其他流操作结合使用。</li></ul><pre><code> //找到一道素食菜肴 Optional&lt;Dish&gt; dish =     menu.stream()     .filter(Dish::isVegetarian)     .findAny(); </code></pre><p>Optional是个什么玩意儿?</p><ul><li><p><strong><em>Optional简介</em></strong></p><p>Optional<t>类（java.util.Optional）是一个容器类，代表一个值存在或不存在。在<br>上面的代码中，findAny可能什么元素都没找到。Java 8的库设计人员引入了Optional<t>，这<br>样就不用返回众所周知容易出问题的null了。</t></t></p><p>Optional里面几种检查值是否存在或处理值不存在的方法</p></li><li>isPresent()将在Optional包含值的时候返回true,否则返回false。</li><li>ifPresent(Consumer<t> block)会在值存在的时候执行给定的代码块。我们在第3章<br>介绍了Consumer函数式接口；它让你传递一个接收T类型参数，并返回void的Lambda<br>表达式。</t></li><li>T get()会在值存在时返回值，否则抛出一个NoSuchElement异常。</li><li>T orElse(T other)会在值存在时返回值，否则返回一个默认值</li></ul><pre><code> //Optional对象中是否存在一道菜可以访问其名称：menu.stream()     .filter(Dish::isVegetarian)     .findAny()     .ifPresent(d -&gt; System.out.println(d.getName());//如果包含一个    //值就打印它，否则什么都不做</code></pre><ul><li><strong>findFirst</strong> 查找第一个元素</li></ul><h2 id="归约"><a href="#归约" class="headerlink" title="归约"></a>归约</h2><ul><li>reduce操作来表达更复杂的查<br>询，比如“计算菜单中的总卡路里”或“菜单中卡路里最高的菜是哪一个”。此类查询需要将流中所有元素反复结合起来，得到一个值。</li></ul><p><strong>元素求和</strong></p><pre><code> int sum = numbers.stream().reduce(0, (a, b) -&gt; a + b);</code></pre><p><strong>最大值</strong></p><pre><code> Optional&lt;Integer&gt; max = numbers.stream().reduce(Integer::max);</code></pre><h1 id="并行流"><a href="#并行流" class="headerlink" title="并行流"></a>并行流</h1><p>并行流就是一个把内容分成多个数据<br>块，并用不同的线程分别处理每个数据块的流。</p><p>传统的Java</p><pre><code>public static long iterativeSum(long n) {   long result = 0;   for (long i = 1L; i &lt;= n; i++) {   result += i;   }  return result;  } </code></pre><p>顺序流</p><pre><code> public static long  sequentialSum((long n) {      return Stream.iterate(1L, i -&gt; i + 1)     .limit(n)     .reduce(0L, Long::sum);     } </code></pre><p>对顺序流调用parallel方法,将顺序流转换为并行流.</p><pre><code>public static long parallelSum(long n) {  return Stream.iterate(1L, i -&gt; i + 1)  .limit(n)  .parallel()  .reduce(0L, Long::sum); } </code></pre><p> <img src="https://s1.ax2x.com/2017/12/27/YCPxe.png" alt=""></p><h2 id="并行流的性能"><a href="#并行流的性能" class="headerlink" title="并行流的性能"></a>并行流的性能</h2><ul><li>测试性能的方法</li></ul><p>测试类</p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">package</span> com<span class="token punctuation">.</span>java8inaction<span class="token punctuation">.</span>part7<span class="token punctuation">;</span><span class="token keyword">import</span> java<span class="token punctuation">.</span>util<span class="token punctuation">.</span>function<span class="token punctuation">.</span>Function<span class="token punctuation">;</span><span class="token keyword">import</span> java<span class="token punctuation">.</span>util<span class="token punctuation">.</span>stream<span class="token punctuation">.</span>Stream<span class="token punctuation">;</span><span class="token comment" spellcheck="true">/** *  * @author geguofeng * */</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">ParallelStreams</span><span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">/**     * 传统Java循环     * @param n     * @return     */</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">long</span> <span class="token function">iterativeSum</span><span class="token punctuation">(</span><span class="token keyword">long</span> n<span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">long</span> result <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> n<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            result <span class="token operator">+=</span> n<span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> result<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">/**     * 顺序流     * @param n     * @return     */</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">long</span> <span class="token function">sequentialSum</span><span class="token punctuation">(</span><span class="token keyword">long</span> n<span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">return</span> Stream<span class="token punctuation">.</span><span class="token function">iterate</span><span class="token punctuation">(</span>1L<span class="token punctuation">,</span> i<span class="token operator">-</span><span class="token operator">></span>i<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">limit</span><span class="token punctuation">(</span>n<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">reduce</span><span class="token punctuation">(</span>0L<span class="token punctuation">,</span> Long<span class="token operator">:</span><span class="token operator">:</span>sum<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">/**     * 并行流     * @param n     * @return     */</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">long</span>  <span class="token function">parallelSum</span><span class="token punctuation">(</span><span class="token keyword">long</span> n<span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">return</span> Stream<span class="token punctuation">.</span><span class="token function">iterate</span><span class="token punctuation">(</span>1L<span class="token punctuation">,</span> i<span class="token operator">-</span><span class="token operator">></span>i<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">limit</span><span class="token punctuation">(</span>n<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">parallel</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">reduce</span><span class="token punctuation">(</span>0L<span class="token punctuation">,</span> Long<span class="token operator">:</span><span class="token operator">:</span>sum<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">/**     * 性能测试：这个方法接受一个函数和一个long作为参数。它会对传给方法的long应用函数10次，记录               每次执行的时间（以毫秒为单位），并返回最短的一次执行时间。     * @param adder     * @param n     * @return     */</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">long</span> <span class="token function">measureSumPerf</span><span class="token punctuation">(</span>Function<span class="token operator">&lt;</span>Long<span class="token punctuation">,</span> Long<span class="token operator">></span>  adder<span class="token punctuation">,</span> <span class="token keyword">long</span> n<span class="token punctuation">)</span> <span class="token punctuation">{</span>         <span class="token keyword">long</span> fastest <span class="token operator">=</span> Long<span class="token punctuation">.</span>MAX_VALUE<span class="token punctuation">;</span>         <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">10</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">long</span> start <span class="token operator">=</span> System<span class="token punctuation">.</span><span class="token function">nanoTime</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">long</span> sum <span class="token operator">=</span> adder<span class="token punctuation">.</span><span class="token function">apply</span><span class="token punctuation">(</span>n<span class="token punctuation">)</span><span class="token punctuation">;</span>             <span class="token keyword">long</span> duration <span class="token operator">=</span> <span class="token punctuation">(</span>System<span class="token punctuation">.</span><span class="token function">nanoTime</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span> start<span class="token punctuation">)</span> <span class="token operator">/</span> 1_000_000<span class="token punctuation">;</span>             <span class="token comment" spellcheck="true">//System.out.println("Result: " + sum); </span>             <span class="token keyword">if</span> <span class="token punctuation">(</span>duration <span class="token operator">&lt;</span> fastest<span class="token punctuation">)</span>                 fastest <span class="token operator">=</span> duration<span class="token punctuation">;</span>              <span class="token punctuation">}</span>             <span class="token keyword">return</span> fastest<span class="token punctuation">;</span>         <span class="token punctuation">}</span>     <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"Sequential sum done in:"</span> <span class="token operator">+</span>                  <span class="token function">measureSumPerf</span><span class="token punctuation">(</span>ParallelStreams<span class="token operator">:</span><span class="token operator">:</span>sequentialSum<span class="token punctuation">,</span> 10_000_000<span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">" msecs"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>         System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"Iterative sum done in:"</span> <span class="token operator">+</span>                  <span class="token function">measureSumPerf</span><span class="token punctuation">(</span>ParallelStreams<span class="token operator">:</span><span class="token operator">:</span>iterativeSum<span class="token punctuation">,</span> 10_000_000<span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">" msecs"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>         System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"Parallel sum done in: "</span> <span class="token operator">+</span>                  <span class="token function">measureSumPerf</span><span class="token punctuation">(</span>ParallelStreams<span class="token operator">:</span><span class="token operator">:</span>parallelSum<span class="token punctuation">,</span> 10_000_000<span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">" msecs"</span> <span class="token punctuation">)</span><span class="token punctuation">;</span>         <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre><code>&gt;Sequential sum done in:107 msecs Iterative sum done in:6 msecs Parallel sum done in: 108 msecs</code></pre><blockquote><p>当令人失望，求和方法的并行版本比顺序版本要慢很多。</p><ul><li>iterate生成的是装箱的对象，必须拆箱成数字才能求和；</li><li>我们很难把iterate分成多个独立块来并行执行。<br>所以要<br><strong><em>使用更有针对性的方法</em></strong><br>LongStream.rangeClosed的方法。这个方法与iterate相比有两个优点。</li><li>LongStream.rangeClosed直接产生原始类型的long数字，没有装箱拆箱的开销。</li><li>LongStream.rangeClosed会生成数字范围，很容易拆分为独立的小块。例如，范围1~20<br>可分为1~5、6~10、11~15和16~20。</li></ul></blockquote><pre class="line-numbers language-Java"><code class="language-Java"> //顺序流 public static long rangedSum(long n) {       return LongStream.rangeClosed(1, n) .reduce(0L, Long::sum);      }      //并行流     public static long parallelRangedSum(long n) {       return LongStream.rangeClosed(1, n)                         .parallel()                         .reduce(0L, Long::sum);       } <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre><code> 输出结果 Sequential range sum done in:6 msecs Parallel range sum done in:3 msecs</code></pre><p>这个数值流比前面那个用iterate工厂方法生成数字的顺序执行版本要快得多，因为数值流<br>避免了非针对性流那些没必要的自动装箱和拆箱操作。由此可见，选择适当的数据结构往往比并<br>行化算法更重要。<br>使用<strong>并行流</strong>的结果终于比使用顺序流的快。<strong><em>这也表明，使用正确的数据结构然后使其并行工作能够保证最佳的性能</em></strong>。</p><blockquote><p>并行流内部使用了默认的ForkJoinPool ，它默认的<br>线程数量就是你的处理器数量，这个值是由 Runtime.getRuntime().availableProcessors()得到的。<br>但是你可以通过系统属性 java.util.concurrent.ForkJoinPool.common.<br>parallelism来改变线程池大小，如下所示：<br>System.setProperty(“java.util.concurrent.ForkJoinPool.common.parallelism”,”12”);这是一个全局设置，因此它将影响代码中所有的并行流。反过来说，目前还无法专为某个<br>并行流指定这个值。一般而言，让ForkJoinPool的大小等于处理器数量是个不错的默认值，<br>除非你有很好的理由，否则我们强烈建议你不要修改它。</p></blockquote><h1 id="Lambda表达式"><a href="#Lambda表达式" class="headerlink" title="Lambda表达式"></a>Lambda表达式</h1><blockquote><p>可以把Lambda表达式理解为简洁地表示可传递的匿名函数的一种方式：它没有名称，但它<br>有参数列表、函数主体、返回类型，可能还有一个可以抛出的异常列表。</p></blockquote><p>先前：</p><pre><code> Comparator&lt;Apple&gt; byWeight = new Comparator&lt;Apple&gt;() {   public int compare(Apple a1, Apple a2){   return a1.getWeight().compareTo(a2.getWeight());    }  }; </code></pre><p>之后（用了Lambda表达式）：</p><pre><code> Comparator&lt;Apple&gt; byWeight = (Apple a1, Apple a2) -&gt; a1.getWeight().compareTo(a2.getWeight()); </code></pre><p>Lambda表达式有三个部分</p><ul><li>参数列表——这里它采用了Comparator中compare方法的参数，两个Apple。</li><li>箭头——箭头   -&gt;  把参数列表与Lambda主体分隔开。</li><li>Lambda主体——比较两个Apple的重量。表达式就是Lambda的返回值了。</li></ul><p>Lambda<br>的基本语法是<br>(parameters) -&gt; expression<br>或（请注意语句的花括号）<br>(parameters) -&gt; { statements; }</p><ul><li>了一些Lambda的例子和使用案例</li></ul><table><thead><tr><th>使用案例</th><th style="text-align:center">Lambda示例</th></tr></thead><tbody><tr><td>布尔表达式</td><td style="text-align:center">(List<string> list) -&gt; list.isEmpty()</string></td></tr><tr><td>创建对象</td><td style="text-align:center">() -&gt; new Apple(10)</td></tr><tr><td>消费一个对象</td><td style="text-align:center">(Apple a) -&gt; { System.out.println(a.getWeight()); }</td></tr><tr><td>从一个对象中选择/抽取</td><td style="text-align:center">(String s) -&gt; s.length()</td></tr><tr><td>组合两个值</td><td style="text-align:center">(int a, int b) -&gt; a * b</td></tr></tbody></table><ul><li>Lambda及其等效方法引用的例子</li></ul><table><thead><tr><th>Lambda</th><th style="text-align:center">等效的方法引用</th></tr></thead><tbody><tr><td>(Apple a) -&gt; a.getWeight()</td><td style="text-align:center">Apple::getWeight</td></tr><tr><td>() -&gt; Thread.currentThread().dumpStack()</td><td style="text-align:center">Thread.currentThread()::dumpStack</td></tr><tr><td>(str, i) -&gt; str.substring(i)</td><td style="text-align:center">String::substring</td></tr><tr><td>(String s) -&gt; System.out.println(s)</td><td style="text-align:center">System.out::println</td></tr></tbody></table><h2 id="如何构造方法引用"><a href="#如何构造方法引用" class="headerlink" title="如何构造方法引用"></a>如何构造方法引用</h2><ul><li>(1) 指向静态方法的方法引用（例如Integer的parseInt方法，写作Integer::parseInt）</li><li>指 向 任意类型实例方法 的方法引用（例如 String 的 length 方法，写作<br>String::length）<br>-(3) 指向现有对象的实例方法的方法引用（假设你有一个局部变量expensiveTransaction<br>用于存放Transaction类型的对象，它支持实例方法getValue，那么你就可以写expensiveTransaction::getValue）</li></ul><p><img src="https://s1.ax2x.com/2017/12/28/0MboG.png" alt=""></p><h1 id="用Optional取代null"><a href="#用Optional取代null" class="headerlink" title="用Optional取代null"></a>用Optional取代null</h1><p>NullPointerException是目前Java程序开发中最典型的异常，它让你的代码充斥着深度嵌套的null检查，代码的可读性糟糕透顶。</p><h2 id="Optional-类入门"><a href="#Optional-类入门" class="headerlink" title="Optional 类入门"></a>Optional 类入门</h2><p>Java 8中引入了一个新的类java.util.Optional<t>。这<br>是一个封装Optional值的类。变量存在时，Optional类只是对类简单封装。变量不存在时，缺失的值会被建模成一个“空”<br>的Optional对象，由方法Optional.empty()返回。</t></p><p>不使用optional的例子</p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Person</span> <span class="token punctuation">{</span>     <span class="token keyword">private</span> Car car<span class="token punctuation">;</span>      <span class="token keyword">public</span> Car <span class="token function">getCar</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token keyword">return</span> car<span class="token punctuation">;</span> <span class="token punctuation">}</span>     <span class="token punctuation">}</span>     <span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Car</span> <span class="token punctuation">{</span>          <span class="token keyword">private</span> Insurance insurance<span class="token punctuation">;</span>          <span class="token keyword">public</span> Insurance <span class="token function">getInsurance</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token keyword">return</span> insurance<span class="token punctuation">;</span> <span class="token punctuation">}</span>     <span class="token punctuation">}</span> <span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Insurance</span> <span class="token punctuation">{</span>  <span class="token keyword">private</span> String name<span class="token punctuation">;</span>  <span class="token keyword">public</span> String <span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token keyword">return</span> name<span class="token punctuation">;</span> <span class="token punctuation">}</span> <span class="token punctuation">}</span> 那么，下面这段代码存在怎样的问题呢？<span class="token keyword">public</span> String <span class="token function">getCarInsuranceName</span><span class="token punctuation">(</span>Person person<span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token keyword">return</span> person<span class="token punctuation">.</span><span class="token function">getCar</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getInsurance</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">}</span> <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p> 如果person.getCar()==null,这个人没有车，就会抛个NullPointerException，</p><p> 使用optional</p><pre class="line-numbers language-Java"><code class="language-Java"> public class Person {  //人可能有车，也可能没有车，因此将这个字段声明为Optional private Optional<Car> car;  public Optional<Car> getCar() { return car; }  }public class Car { //车可能进行了保险，也可能没有保险，所以将这个字段声明为ptional private Optional<Insurance> insurance;  public Optional<Insurance> getInsurance() { return insurance; } } public class Insurance {  private String name;  public String getName() { return name; }} <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>null引用和Optional.empty()<br>有什么本质的区别吗？从语义上，你可以把它们当作一回事儿，但是实际中它们之间的差别非常<br>大：如果你尝试解引用一个 null ，一定会触发 NullPointerException ，不过使用<br>Optional.empty()就完全没事儿</p></blockquote><h2 id="应用-Optional-的几种模式"><a href="#应用-Optional-的几种模式" class="headerlink" title="应用 Optional 的几种模式"></a>应用 Optional 的几种模式</h2><h3 id="创建-Optional-对象"><a href="#创建-Optional-对象" class="headerlink" title="创建 Optional 对象"></a>创建 Optional 对象</h3><ul><li><ol><li>声明一个空的Optional<br>正如前文已经提到，你可以通过静态工厂方法Optional.empty，创建一个空的Optional<br>对象：</li></ol></li></ul><pre><code> Optional&lt;Car&gt; optCar = Optional.empty(); </code></pre><ul><li><ol start="2"><li>依据一个非空值创建Optional<br>你还可以使用静态工厂方法Optional.of，依据一个非空值创建一个Optional对象：如果car是一个null，这段代码会立即抛出一个NullPointerException，而不是等到你<br>试图访问car的属性值时才返回一个错误。</li></ol></li></ul><pre><code>Optional&lt;Car&gt; optCar = Optional.of(car); </code></pre><ul><li><ol start="3"><li>可接受null的Optional<br>最后，使用静态工厂方法Optional.ofNullable，你可以创建一个允许null值的Optional<br>对象：</li></ol></li></ul><pre><code> Optional&lt;Car&gt; optCar = Optional.ofNullable(car); </code></pre><p>如果car是null，那么得到的Optional对象就是个空对象。</p><h3 id="使用-map-从-Optional-对象中提取和转换值"><a href="#使用-map-从-Optional-对象中提取和转换值" class="headerlink" title="使用 map 从 Optional 对象中提取和转换值"></a>使用 map 从 Optional 对象中提取和转换值</h3><p>比如，你可能想要从insurance公司对象中提取<br>公司的名称。提取名称之前，你需要检查insurance对象是否为null，代码如下所示：</p><pre><code> String name = null;  if(insurance != null){   name = insurance.getName();  } </code></pre><p>为了支持这种模式，Optional提供了一个map方法。它的工作方式如下：</p><pre><code>Optional&lt;Insurance&gt; optInsurance = Optional.ofNullable(insurance); Optional&lt;String&gt; name = optInsurance.map(Insurance::getName); public String getCarInsuranceName(Person person) { return person.getCar().getInsurance().getName(); } </code></pre><h3 id="使用-flatMap-链接-Optional-对象"><a href="#使用-flatMap-链接-Optional-对象" class="headerlink" title="使用 flatMap 链接 Optional 对象"></a>使用 flatMap 链接 Optional 对象</h3><p>利用map重写之前的代码</p><pre><code> Optional&lt;Person&gt; optPerson = Optional.of(person);     Optional&lt;String&gt; name =      optPerson.map(Person::getCar)      .map(Car::getInsurance)      .map(Insurance::getName); </code></pre><p>无法通过编译。为什么呢？optPerson是Optional<person>类型的<br>变量， 调用map方法应该没有问题。但getCar返回的是一个Optional<car>类型的对象（如代<br>码清单10-4所示），这意味着map操作的结果是一个Optional&lt;Optional<car>&gt;类型的对象。因<br>此，它对getInsurance的调用是非法的，因为最外层的optional对象包含了另一个optional<br>对象的值，而它当然不会支持getInsurance方法。</car></car></person></p><blockquote><p>latMap方法接受一个函数作为参数，这个函数的返回值是另一个流。<br>这个方法会应用到流中的每一个元素，最终形成一个新的流的流。但是flagMap会用流的内容替<br>换每个新生成的流。</p></blockquote><pre><code>public String getCarInsuranceName(Optional&lt;Person&gt;  person) {  return person.flatMap(Person::getCar)  .flatMap(Car::getInsurance)  .map(Insurance::getName)  .orElse(&quot;Unknown&quot;);  } </code></pre><p>由Optional<person>对象，我们可以结合使用之前介绍的map和flatMap方法，从Person<br>中解引用出Car，从Car中解引用出Insurance，从Insurance对象中解引用出包含insurance<br>公司名称的字符串。<br><img src="https://s1.ax2x.com/2017/12/29/0KGFz.png" alt=""></person></p><h3 id="默认行为及解引用-Optional-对象"><a href="#默认行为及解引用-Optional-对象" class="headerlink" title="默认行为及解引用 Optional 对象"></a>默认行为及解引用 Optional 对象</h3><p>Optional类提供了多种方法读取<br>Optional实例中的变量值</p><ul><li>get()是这些方法中最简单但又最不安全的方法。如果变量存在，它直接返回封装的变量<br>值，否则就抛出一个NoSuchElementException异常。</li><li>orElse(T other)允许你在Optional对象不包含值时提供一个默认值。</li><li>orElseGet(Supplier&lt;? extends T&gt; other)是orElse方法的延迟调用版，Supplier<br>方法只有在Optional对象不含值时才执行调用</li><li>orElseThrow(Supplier&lt;? extends X&gt; exceptionSupplier)和get方法非常类似，<br>它们遭遇Optional对象为空时都会抛出一个异常，但是使用orElseThrow你可以定制希<br>望抛出的异常类型。</li><li>ifPresent(Consumer&lt;? super T&gt;)让你能在变量值存在时执行一个作为参数传入的<br>方法，否则就不进行任何操作。</li></ul><h3 id="使用-filter-剔除特定的值"><a href="#使用-filter-剔除特定的值" class="headerlink" title="使用 filter 剔除特定的值"></a>使用 filter 剔除特定的值</h3><pre><code> Optional&lt;Insurance&gt; optInsurance = ...;  optInsurance.filter(insurance -&gt;   &quot;CambridgeInsurance&quot;.equals(insurance.getName()))   .ifPresent(x -&gt; System.out.println(&quot;ok&quot;)); </code></pre>]]></content>
      
      
      <categories>
          
          <category> Java 8 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> Lambda </tag>
            
            <tag> Stream </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>设计模式：适配器模式</title>
      <link href="/2017/07/09/adapter/"/>
      <url>/2017/07/09/adapter/</url>
      
        <content type="html"><![CDATA[<p>将一个类的接口转换成客户期望的另一个接口，使原本接口不兼容的类可以一起工作。属于结构型设计模式</p><h2 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h2><ul><li>能提高类的透明性和复用，现有的类复用但不需要改变</li><li>目标类和适配器类解耦，提高程序扩展性</li><li>符合开闭原则</li></ul><h2 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h2><p>适配器模式不是软件设计阶段考虑的模式，是随着软件维护，由于不同产品，不同厂商造成功能类似而接口不相同的情况下的解决方案。编写过程中要全面考虑，可能会真假系统的复杂性，降低代码的可读性。</p><h2 id="元素"><a href="#元素" class="headerlink" title="元素"></a>元素</h2><ul><li>Target ：客户期望的接口</li><li>Adaptee ：被适配者，需要被适配的接口</li><li>Adapter : 适配器</li></ul><h2 id="类适配器模式"><a href="#类适配器模式" class="headerlink" title="类适配器模式"></a>类适配器模式</h2><p>Adapter类通过继承Adaptee类，实现Targer类接口，完成Adaptee到Target的适配</p><h4 id="类适配器代码实例"><a href="#类适配器代码实例" class="headerlink" title="类适配器代码实例"></a>类适配器代码实例</h4><ul><li><p>一个220V的电压电源插孔</p><pre class="line-numbers language-Java"><code class="language-Java">public class Voltage220V {  public int output220V(){      int voltage = 220;      System.out.println(String.format("output voltage ： %sV", voltage));      return voltage;  }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>5V的充电口接口</p><pre class="line-numbers language-Java"><code class="language-Java">public interface Voltage5V {  public int output5V();}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>适配器</p><pre class="line-numbers language-Java"><code class="language-Java">public class VoltageAdapter extends Voltage220V implements Voltage5V {  @Override  public int output5V() {      int voltage = super.output220V();      int target = voltage / 44;      return target;  }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ul><h4 id="对象适配器"><a href="#对象适配器" class="headerlink" title="对象适配器"></a>对象适配器</h4><p>类适配器模式中 VoltageAdapter 是继承被适配的类，由于java的单继承，这里采用组合关系改造VoltageAdapter</p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">VoltageAdapter</span> <span class="token keyword">implements</span> <span class="token class-name">Voltage5V</span> <span class="token punctuation">{</span>    <span class="token keyword">private</span> Voltage220V voltage220V <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Voltage220V</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">output5V</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> voltage <span class="token operator">=</span> voltage220V<span class="token punctuation">.</span><span class="token function">output220V</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> target <span class="token operator">=</span> voltage <span class="token operator">/</span> <span class="token number">44</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> target<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 设计模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 设计模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>设计模式：单例模式</title>
      <link href="/2017/07/04/singleton/"/>
      <url>/2017/07/04/singleton/</url>
      
        <content type="html"><![CDATA[<p>单例模式就是采取一定方法保证在整个软件系统中，对于某个类只能存在一个对象的实例，并且该类只提供一个取得其对象实例的方法。属于创建型。</p><h2 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h2><ul><li>在内存里只有一个实例，减少了内存开销</li><li>可以避免对资源的多重占用</li><li>设置全局访问点，严格控制访问</li></ul><h2 id="单例的实现"><a href="#单例的实现" class="headerlink" title="单例的实现"></a>单例的实现</h2><h4 id="懒汉式"><a href="#懒汉式" class="headerlink" title="懒汉式"></a>懒汉式</h4><pre class="line-numbers language-Java"><code class="language-Java">/** * 懒汉式单例模式 * (在多线程下不能保证创建的实例是唯一的) */public class LazySingleton {    private LazySingleton(){}    //和饿汉式不同，这里不实例化，而是在需要的时候再去new    private static LazySingleton instance;    //在多线程下不能保证创建的实例是唯一的    public static LazySingleton getInstance(){        if(instance==null){            instance = new LazySingleton();        }        return instance;    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="懒汉式改进（线程安全）"><a href="#懒汉式改进（线程安全）" class="headerlink" title="懒汉式改进（线程安全）"></a>懒汉式改进（线程安全）</h4><pre class="line-numbers language-Java"><code class="language-Java">/** * 懒汉式改进 线程安全的单例模式 */public class SynchronizedSingleton {    private SynchronizedSingleton(){}    //和饿汉式不同，这里不实例化，而是在需要的时候再去new    private static volatile SynchronizedSingleton instance;    //双重加锁    public static SynchronizedSingleton getInstance(){        if(instance == null){            synchronized (SynchronizedSingleton.class){                if(instance == null){                    instance = new SynchronizedSingleton();                }            }        }        return instance;    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>使用synchronized保证创建单例对象时的线程安全，使用volatile修饰instance，防止在执行instance = new SynchronizedSingleton()时候发生指令重排序带来线程安全问题。</p><h4 id="静态内部类"><a href="#静态内部类" class="headerlink" title="静态内部类"></a>静态内部类</h4><pre class="line-numbers language-java"><code class="language-java"><span class="token comment" spellcheck="true">/** * 内部类实现单例模式 */</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">InnerClassSingleton</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> InnerClassSingleton <span class="token function">getInstance</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">return</span> Singleton<span class="token punctuation">.</span>singleton<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">class</span> <span class="token class-name">Singleton</span><span class="token punctuation">{</span>        <span class="token keyword">private</span> <span class="token keyword">static</span> InnerClassSingleton singleton <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">InnerClassSingleton</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">private</span> <span class="token function">InnerClassSingleton</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="饿汉式"><a href="#饿汉式" class="headerlink" title="饿汉式"></a>饿汉式</h4><pre class="line-numbers language-Java"><code class="language-Java">/** * 饿汉式单例模式 */public class HungrySingleton {    //将构造函数私有化，不允许外部对象直接调用    private HungrySingleton(){}    private static final HungrySingleton instance = new HungrySingleton();    //对外提供唯一用于获取实例的方法    public static HungrySingleton getInstance(){        return instance;    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="枚举实现单例"><a href="#枚举实现单例" class="headerlink" title="枚举实现单例"></a>枚举实现单例</h4><pre class="line-numbers language-Java"><code class="language-Java">    public enum EnumSingleton {        INSTANCE;     }<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 设计模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 设计模式 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
